<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Villager Planner (Cost == 1)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<style>
  :root{
    --bg:#0b0f14;
    --panel:#121a24;
    --panel2:#0f1722;
    --border:#223044;
    --border2:#2b3f5d;
    --text:#e7eef7;
    --muted:#a9b7c9;
    --ok:#8ee5a1;
    --bad:#ff9aa5;
    --pillCost1:#2c6b3f;
    --pillCostN:#5d3b2b;
  }

  *{ box-sizing:border-box; }
  body{
    margin:0;
    background:var(--bg);
    color:var(--text);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
  }

  /* Sticky header */
  header{
    position:sticky;
    top:0;
    z-index:50;
    background:rgba(11,15,20,.92);
    backdrop-filter: blur(8px);
    border-bottom:1px solid var(--border);
  }
  .wrap{ max-width:1200px; margin:0 auto; padding:16px; }

  h1{ margin:0; font-size:20px; letter-spacing:.2px; }
  .sub{ margin-top:6px; color:var(--muted); font-size:12px; }

  .panel{
    background:var(--panel);
    border:1px solid var(--border);
    border-radius:12px;
  }

  .controls{
    margin-top:12px;
    display:flex;
    gap:12px;
    flex-wrap:wrap;
    align-items:flex-end;
  }
  .control{
    display:flex;
    flex-direction:column;
    gap:6px;
    min-width:220px;
  }
  label{ font-size:12px; color:var(--muted); }
  input[type="text"], select{
    width:100%;
    background:var(--bg);
    color:var(--text);
    border:1px solid var(--border);
    padding:9px 10px;
    border-radius:10px;
    outline:none;
  }
  input[type="text"]:focus, select:focus{
    border-color:#3a5276;
  }

  .toggles{
    display:flex;
    gap:10px;
    align-items:center;
    padding-bottom:2px;
    min-width:260px;
  }
  .toggle{
    display:flex;
    gap:8px;
    align-items:center;
    font-size:13px;
    color:var(--text);
  }
  .toggle input{ transform: translateY(1px); }

  button{
    background:#1d2a3c;
    color:var(--text);
    border:1px solid var(--border2);
    padding:9px 12px;
    border-radius:10px;
    cursor:pointer;
    font-weight:600;
  }
  button:hover{ background:#22344c; }

  .status{
    margin-top:10px;
    font-size:12px;
    color:var(--muted);
  }
  .ok{ color:var(--ok); }
  .error{ color:var(--bad); }

  /* Summary cards */
  main{ max-width:1200px; margin:0 auto; padding:16px; display:flex; flex-direction:column; gap:12px; }
  .summaryGrid{
    display:grid;
    gap:12px;
  }
  @media(min-width:1000px){
    .summaryGrid{ grid-template-columns: 1fr 1fr 1fr; }
  }
  .card{
    padding:12px;
    background:var(--panel);
    border:1px solid var(--border);
    border-radius:12px;
    min-height:110px;
  }
  .cardTitle{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    font-size:12px;
    color:var(--muted);
    margin-bottom:8px;
  }
  .countBadge{
    font-size:12px;
    color:var(--text);
    border:1px solid var(--border2);
    background:var(--panel2);
    padding:2px 8px;
    border-radius:999px;
    white-space:nowrap;
  }

  .pill{
    display:inline-block;
    padding:2px 8px;
    border-radius:999px;
    border:1px solid var(--border2);
    margin:2px 6px 2px 0;
    font-size:12px;
    white-space:nowrap;
  }
  .cost1{ border-color:var(--pillCost1); }
  .costN{ border-color:var(--pillCostN); }
  .tag{
    display:inline-block;
    padding:2px 8px;
    border-radius:999px;
    border:1px solid var(--border2);
    font-size:12px;
    margin-left:8px;
    background:var(--panel2);
  }
  .tag.best{ border-color:var(--pillCost1); }
  .tag.dup{ border-color:var(--bad); color:var(--bad); }

  .mono{
    font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
    font-size:12px;
    white-space:pre-wrap; /* wrap nicely */
    word-break:break-word;
    background:var(--panel2);
    border:1px solid var(--border);
    border-radius:10px;
    padding:10px;
    margin:0;
  }

  /* Desktop table */
  .tableWrap{
    overflow:auto;
    border-radius:12px;
  }
  table{ width:100%; border-collapse:collapse; min-width:900px; }
  th, td{ border-bottom:1px solid var(--border); padding:12px; vertical-align:top; }
  th{
    position:sticky;
    top:0;
    background:var(--panel);
    color:#cfe2ff;
    text-align:left;
  }

  /* Mobile cards */
  .villagerCards{ display:none; gap:12px; }
  .villagerCard{
    padding:12px;
    border:1px solid var(--border);
    border-radius:12px;
    background:var(--panel);
  }
  .vcHeader{
    display:flex;
    align-items:flex-start;
    justify-content:space-between;
    gap:10px;
    margin-bottom:10px;
  }
  .vcName{ font-weight:800; }
  .vcSectionTitle{ color:var(--muted); font-size:12px; margin:10px 0 6px; }
  .vcActions{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }

  @media(max-width: 980px){
    .tableWrap{ display:none; }
    .villagerCards{ display:grid; }
  }
</style>
</head>

<body>

<header>
  <div class="wrap">
    <h1>Villager Planner — Cost == 1 Only</h1>
    <div class="sub">Find the minimum set of villagers that covers all cost==1 goal enchants, and generate sign text.</div>

    <div class="controls">
      <div class="control">
        <label for="villagerFile">Villager file</label>
        <select id="villagerFile">
          <option value="./rebirth_rock.json">Rebirth Rock</option>
          <option value="./donut_island_trading_hall.json">Donut Island Trading Hall</option>
        </select>
      </div>

      <div class="control" style="flex:1; min-width:260px">
        <label for="search">Search</label>
        <input id="search" type="text" placeholder="villager or enchant…" />
      </div>

      <div class="toggles panel" style="padding:10px 12px; border-radius:12px;">
        <label class="toggle" title="Hide non-goal enchants in the display">
          <input id="onlyGoal" type="checkbox" checked>
          goal enchants only
        </label>
        <label class="toggle" title="Show only enchants priced at 1 emerald (pre/post-cure logic still applies)">
          <input id="onlyCost1" type="checkbox">
          cost==1 only
        </label>
      </div>

      <div class="control" style="min-width:140px">
        <label>&nbsp;</label>
        <button id="reloadBtn">Reload</button>
      </div>
    </div>

    <div class="status" id="status">Idle</div>
  </div>
</header>

<main>
  <section class="summaryGrid">
    <div class="card">
      <div class="cardTitle">
        <span>Best set (minimum villagers covering all cost==1 obtainable goal enchants)</span>
        <span class="countBadge" id="bestCount">0</span>
      </div>
      <div id="bestSet"></div>
    </div>

    <div class="card">
      <div class="cardTitle">
        <span>Missing enchantments (vs master list)</span>
        <span class="countBadge" id="missingCount">0</span>
      </div>
      <div id="missingList"></div>
    </div>

    <div class="card">
      <div class="cardTitle">
        <span>Extraneous villagers (not in best set)</span>
        <span class="countBadge" id="extrasCount">0</span>
      </div>
      <div id="extrasList"></div>
    </div>
  </section>

  <!-- Desktop table -->
  <section class="panel tableWrap">
    <table>
      <thead>
        <tr>
          <th style="width:220px">Villager</th>
          <th>Enchantments</th>
          <th style="width:220px">Add-ons</th>
          <th style="width:380px">Sign code</th>
        </tr>
      </thead>
      <tbody id="tbody"></tbody>
    </table>
  </section>

  <!-- Mobile cards -->
  <section class="villagerCards" id="cards"></section>
</main>

<script>
(() => {
  const ENCHANTMENTS_JSON = "./enchantments.json";

  function currentVillagersPath() {
    const sel = $("villagerFile");
    return (sel && sel.value) ? sel.value : "./rebirth_rock.json";
  }

  function isDonutIsland() {
    const p = currentVillagersPath().toLowerCase();
    return p.includes("donut");
  }

  function getFileFromURL() {
    const p = new URLSearchParams(window.location.search);
    return p.get("file"); // e.g. "./rebirth_rock.json" or "rebirth_rock.json"
  }

  function setFileInURL(value) {
    const url = new URL(window.location.href);
    url.searchParams.set("file", value);
    history.replaceState(null, "", url.toString());
  }

  const ALIASES = {
    "Aqua Affinity I": "Aqua Affinity",
    "Channeling I": "Channeling",
    "Curse of Binding I": "Curse of Binding",
    "Curse of Vanishing I": "Curse of Vanishing",
    "Flame I": "Flame",
    "Infinity I": "Infinity",
    "Mending I": "Mending",
    "Multishot I": "Multishot",
    "Silk Touch I": "Silk Touch"
  };

  const $ = (id) => document.getElementById(id);
  const normalize = (k) => (ALIASES[(k ?? "").toString().trim()] || (k ?? "").toString().trim());

  function priceFor(v, raw) {
    if (typeof raw === "number") return raw;
    if (raw && typeof raw === "object") {
      const cured = !!v.cured;
      const val = raw[cured ? "post" : "pre"];
      if (val === null || val === undefined || val === "X") return null;
      const n = Number(val);
      return Number.isFinite(n) ? n : null;
    }
    return null;
  }

  function bitCountBig(m) {
    let c = 0;
    while (m) { c++; m &= (m - 1n); }
    return c;
  }
  function tzBig(lsb) {
    let z = 0;
    while ((lsb >> BigInt(z)) !== 1n) z++;
    return z;
  }

  async function loadJSON(path) {
    const r = await fetch(path, { cache: "no-store" });
    if (!r.ok) throw new Error(`Failed to load ${path} (${r.status})`);
    return r.json();
  }

  function escapeHtml(s) {
    return (s ?? "").toString()
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  function pillHTML(text, isCost1) {
    return `<span class="pill ${isCost1 ? "cost1" : "costN"}">${escapeHtml(text)}</span>`;
  }

  function buildSign(villagerName, cost1Enchants, costNEnchants, options, isDuplicate) {
    const donut = isDonutIsland();

    const colorCost1 = donut ? "§d" : "§6"; // pink / gold
    const colorCostN = "§7";               // gray
    const colorOpts  = donut ? "§b" : "§b"; // purple / aqua

    const lines = [];

    if (isDuplicate) {
      lines.push("§cDUPLICATE");
    }

    if (cost1Enchants.length) {
      cost1Enchants.forEach(e => lines.push(`${colorCost1}${e}`));
    }

    if (costNEnchants.length) {
      costNEnchants.forEach(e => lines.push(`${colorCostN}${e}`));
    }

    if (!cost1Enchants.length && !costNEnchants.length) {
      lines.push(`${colorCostN}(no goal enchants)`);
    }

    const optsLine = options && options.length
      ? `${colorOpts}${options.join(" | ")}`
      : `${colorOpts}(no add-ons)`;

    lines.push(optsLine);

    return lines.join("\n");
  }

  function computeCost1Coverage(villagers, goals) {
    const goalList = [...goals].sort((a,b)=>a.localeCompare(b));
    const idx = new Map(goalList.map((g,i)=>[g,i]));

    const villagerMasks = [];
    let obtainableMask = 0n;

    for (const name of Object.keys(villagers).sort((a,b)=>a.localeCompare(b))) {
      const v = villagers[name];
      const enchRaw = v.enchantments || {};
      let mask = 0n;
      const covers = [];

      for (const g of goalList) {
        let p = null;

        if (Object.prototype.hasOwnProperty.call(enchRaw, g)) {
          p = priceFor(v, enchRaw[g]);
        } else {
          for (const [k,val] of Object.entries(enchRaw)) {
            if (normalize(k) === g) { p = priceFor(v, val); break; }
          }
        }

        if (p === 1) {
          const bit = idx.get(g);
          mask |= (1n << BigInt(bit));
          covers.push(g);
        }
      }

      if (mask !== 0n) {
        villagerMasks.push({ name, mask, covers: covers.sort((a,b)=>a.localeCompare(b)) });
        obtainableMask |= mask;
      }
    }

    return { goalList, idx, villagerMasks, obtainableMask };
  }

  function solveMinSetCoverExact(villagerMasks, targetMask) {
    if (targetMask === 0n) return [];

    const items = [...villagerMasks].sort((a,b)=>bitCountBig(b.mask) - bitCountBig(a.mask));
    const maxCover = items.length ? bitCountBig(items[0].mask) : 0;
    if (maxCover === 0) return null;

    const bitToItems = new Map();
    for (let i = 0; i < items.length; i++) {
      let m = items[i].mask;
      while (m) {
        const lsb = m & (-m);
        const bit = tzBig(lsb);
        if (!bitToItems.has(bit)) bitToItems.set(bit, []);
        bitToItems.get(bit).push(i);
        m ^= lsb;
      }
    }

    function greedyUpperBound() {
      let rem = targetMask;
      const chosen = [];
      while (rem) {
        let best = -1, bestGain = 0;
        for (let i = 0; i < items.length; i++) {
          const gain = bitCountBig(items[i].mask & rem);
          if (gain > bestGain) { bestGain = gain; best = i; }
        }
        if (best < 0 || bestGain === 0) return null;
        chosen.push(best);
        rem &= ~items[best].mask;
      }
      return chosen;
    }

    const ub = greedyUpperBound();
    let best = ub ? [...ub] : null;
    let bestLen = ub ? ub.length : Infinity;

    function pickMRVBit(remMask) {
      let mm = remMask;
      let bestBit = null, bestCount = 1e9;
      while (mm) {
        const lsb = mm & (-mm);
        const bit = tzBig(lsb);
        const c = (bitToItems.get(bit) || []).length;
        if (c < bestCount) {
          bestCount = c;
          bestBit = bit;
          if (c <= 1) break;
        }
        mm ^= lsb;
      }
      return bestBit;
    }

    function dfs(chosen, covered) {
      if (covered === targetMask) {
        if (chosen.length < bestLen) {
          bestLen = chosen.length;
          best = [...chosen];
        }
        return;
      }
      if (chosen.length >= bestLen) return;

      const remaining = targetMask & ~covered;
      const remBits = bitCountBig(remaining);
      const lower = Math.ceil(remBits / maxCover);
      if (chosen.length + lower >= bestLen) return;

      const bit = pickMRVBit(remaining);
      if (bit == null) return;

      const candidates = (bitToItems.get(bit) || [])
        .slice()
        .sort((i,j) => bitCountBig(items[j].mask & remaining) - bitCountBig(items[i].mask & remaining));

      for (const i of candidates) {
        const newCovered = covered | items[i].mask;
        if (newCovered === covered) continue;
        dfs([...chosen, i], newCovered);
      }
    }

    dfs([], 0n);

    if (!best) return null;
    return best.map(i => items[i].name);
  }

  function renderOptimizationPanels(villagers, masterGoalList, addonList) {
    const addonSet = new Set(addonList);

    const availableAny = new Set();
    const availableCost1 = new Set();

    for (const v of Object.values(villagers)) {
      const enchRaw = v.enchantments || {};
      for (const [k, val] of Object.entries(enchRaw)) {
        const nk = normalize(k);
        if (addonSet.has(nk)) continue;
        const p = priceFor(v, val);
        availableAny.add(nk);
        if (p === 1) availableCost1.add(nk);
      }
    }

    const master = [...masterGoalList].sort((a,b)=>a.localeCompare(b));
    const missingEntirely = master.filter(e => !availableAny.has(e));
    const missingCost1 = master.filter(e => !availableCost1.has(e));

    // Missing panel + count
    const missingCount = (missingEntirely.length + missingCost1.length);
    $("missingCount").textContent = String(missingCount);

    if (!missingEntirely.length && !missingCost1.length) {
      $("missingList").innerHTML = `<span class="ok">None</span>`;
    } else {
      const parts = [];
      if (missingEntirely.length) {
        parts.push(`<div class="muted" style="margin-bottom:6px">Missing entirely</div>`);
        parts.push(missingEntirely.map(e => pillHTML(e, false)).join(" "));
      } else {
        parts.push(`<div class="muted">Missing entirely</div><span class="ok">None</span>`);
      }

      parts.push(`<div style="height:10px"></div>`);

      if (missingCost1.length) {
        parts.push(`<div class="muted" style="margin-bottom:6px">Missing at cost==1</div>`);
        parts.push(missingCost1.map(e => pillHTML(e, false)).join(" "));
      } else {
        parts.push(`<div class="muted">Missing at cost==1</div><span class="ok">None</span>`);
      }

      $("missingList").innerHTML = parts.join("");
    }

    const optimizationGoals = master.filter(e => availableCost1.has(e));
    const { villagerMasks, obtainableMask } = computeCost1Coverage(villagers, optimizationGoals);
    const best = solveMinSetCoverExact(villagerMasks, obtainableMask) || [];
    const bestSet = new Set(best);

    $("bestCount").textContent = String(best.length);

    if (!best.length) {
      $("bestSet").innerHTML = `<span class="muted">(none)</span>`;
    } else {
      // Build rows with their already-sorted covers
      const rows = best.map(name => {
        const covers = (villagerMasks.find(x => x.name === name)?.covers) || [];
        return {
          name,
          covers,
          first: (covers[0] || "\uffff").toString() // put "no covers" at end safely
        };
      });

      // Sort villagers by first covered enchantment, then by villager name
      rows.sort((a, b) => {
        const c = a.first.localeCompare(b.first);
        if (c !== 0) return c;
        return a.name.localeCompare(b.name);
      });

      const lines = rows.map(r =>
        `<div style="margin-bottom:8px"><b>${escapeHtml(r.name)}</b>: ${r.covers.map(c => pillHTML(c, true)).join(" ")}</div>`
      );

      $("bestSet").innerHTML = lines.join("");
    }


    const extras = Object.keys(villagers)
      .filter(n => !bestSet.has(n))
      .sort((a,b)=>a.localeCompare(b));

    $("extrasCount").textContent = String(extras.length);

    $("extrasList").innerHTML = extras.length
      ? extras.map(n => `<span class="pill">${escapeHtml(n)}</span>`).join(" ")
      : `<span class="ok">None</span>`;

    return bestSet;
  }

  function makeCopyButton(text) {
    const btn = document.createElement("button");
    btn.textContent = "Copy";
    btn.addEventListener("click", async () => {
      try {
        await navigator.clipboard.writeText(text);
        btn.textContent = "Copied!";
        setTimeout(() => (btn.textContent = "Copy"), 900);
      } catch {
        btn.textContent = "Clipboard blocked";
        setTimeout(() => (btn.textContent = "Copy"), 1200);
      }
    });
    return btn;
  }

  function renderTableAndCards(villagers, goalList, addonList, bestSet) {
    const tbody = $("tbody");
    const cards = $("cards");
    tbody.innerHTML = "";
    cards.innerHTML = "";

    const goalSet = new Set(goalList);
    const addonSet = new Set(addonList);

    const searchTerm = $("search").value.trim().toLowerCase();
    const onlyGoal = $("onlyGoal").checked;
    const onlyCost1 = $("onlyCost1").checked;

    const names = Object.keys(villagers).sort((a,b)=>a.localeCompare(b));
    let shown = 0;

    for (const name of names) {
      const v = villagers[name];
      const enchRaw = v.enchantments || {};

      const goalEnchants = [];
      const otherEnchants = [];
      const addons = [];

      for (const [k,val] of Object.entries(enchRaw)) {
        const nk = normalize(k);
        const p = priceFor(v, val);

        if (goalSet.has(nk)) goalEnchants.push({ name: nk, price: p });
        else if (addonSet.has(nk)) addons.push(nk);
        else otherEnchants.push({ name: nk, price: p });
      }

      goalEnchants.sort((a,b)=>a.name.localeCompare(b.name));
      otherEnchants.sort((a,b)=>a.name.localeCompare(b.name));
      addons.sort((a,b)=>a.localeCompare(b));

      let displayed = onlyGoal ? goalEnchants : goalEnchants.concat(otherEnchants);
      if (onlyCost1) displayed = displayed.filter(e => e.price === 1);

      const blob = [
        name,
        ...goalEnchants.map(e => `${e.name} ${e.price ?? ""}`),
        ...otherEnchants.map(e => `${e.name} ${e.price ?? ""}`),
        ...addons
      ].join(" ").toLowerCase();

      if (searchTerm && !blob.includes(searchTerm)) continue;

      const isDuplicate = !bestSet.has(name);
      const goalCost1 = goalEnchants.filter(e => e.price === 1).map(e => e.name);
      const goalCostN = goalEnchants.filter(e => e.price !== 1).map(e => e.name);

      const sign = buildSign(name, goalCost1, goalCostN, addons, isDuplicate);

      // ---- Desktop row ----
      const tr = document.createElement("tr");

      const tdName = document.createElement("td");
      const tags = [
        bestSet.has(name) ? `<span class="tag best">BEST SET</span>` : ``,
        isDuplicate ? `<span class="tag dup">DUPLICATE</span>` : ``
      ].filter(Boolean).join(" ");

      tdName.innerHTML = `<b>${escapeHtml(name)}</b> ${tags}`;
      tr.appendChild(tdName);

      const tdEnch = document.createElement("td");
      if (!displayed.length) {
        tdEnch.innerHTML = `<span class="muted">(none)</span>`;
      } else {
        tdEnch.innerHTML = displayed.map(e => {
          const cls = (e.price === 1) ? "cost1" : "costN";
          const p = (e.price === null || e.price === undefined) ? "?" : e.price;
          return `<span class="pill ${cls}">${escapeHtml(e.name)} (${p})</span>`;
        }).join("");
      }
      tr.appendChild(tdEnch);

      const tdAdd = document.createElement("td");
      tdAdd.innerHTML = addons.length ? escapeHtml(addons.join(", ")) : `<span class="muted">(none)</span>`;
      tr.appendChild(tdAdd);

      const tdSign = document.createElement("td");
      const pre = document.createElement("pre");
      pre.className = "mono";
      pre.textContent = sign;

      const actions = document.createElement("div");
      actions.style.marginTop = "8px";
      actions.appendChild(makeCopyButton(sign));

      tdSign.appendChild(pre);
      tdSign.appendChild(actions);
      tr.appendChild(tdSign);

      tbody.appendChild(tr);

      // ---- Mobile card ----
      const card = document.createElement("div");
      card.className = "villagerCard";

      const head = document.createElement("div");
      head.className = "vcHeader";

      const left = document.createElement("div");
      left.innerHTML = `<div class="vcName">${escapeHtml(name)} ${
        bestSet.has(name) ? `<span class="tag best">BEST SET</span>` : ``
      } ${
        isDuplicate ? `<span class="tag dup">DUPLICATE</span>` : ``
      }</div>`;

      const right = document.createElement("div");
      right.className = "vcActions";
      right.appendChild(makeCopyButton(sign));

      head.appendChild(left);
      head.appendChild(right);

      const enchWrap = document.createElement("div");
      enchWrap.innerHTML = `<div class="vcSectionTitle">Enchantments</div>` +
        (displayed.length
          ? displayed.map(e => {
              const cls = (e.price === 1) ? "cost1" : "costN";
              const p = (e.price === null || e.price === undefined) ? "?" : e.price;
              return `<span class="pill ${cls}">${escapeHtml(e.name)} (${p})</span>`;
            }).join("")
          : `<span class="muted">(none)</span>`
        );

      const addWrap = document.createElement("div");
      addWrap.innerHTML = `<div class="vcSectionTitle">Add-ons</div>` +
        (addons.length ? escapeHtml(addons.join(", ")) : `<span class="muted">(none)</span>`);

      const signWrap = document.createElement("div");
      signWrap.innerHTML = `<div class="vcSectionTitle">Sign code</div>`;
      const pre2 = document.createElement("pre");
      pre2.className = "mono";
      pre2.textContent = sign;

      card.appendChild(head);
      card.appendChild(enchWrap);
      card.appendChild(addWrap);
      card.appendChild(signWrap);
      card.appendChild(pre2);

      cards.appendChild(card);

      shown++;
    }

    const srcLabel = ($("villagerFile")?.selectedOptions?.[0]?.textContent || "Villagers").trim();
    $("status").innerHTML = `<span class="ok">Loaded</span> — ${escapeHtml(srcLabel)} — showing ${shown} / ${names.length} villagers`;
  }

  let _villagers = null;
  let _goalList = [];
  let _addonList = [];
  let _bestSet = new Set();

  async function reload() {
    try {
      $("status").textContent = "Loading…";
      const [villagers, master] = await Promise.all([
        loadJSON(currentVillagersPath()),
        loadJSON(ENCHANTMENTS_JSON)
      ]);

      _villagers = villagers;

      _goalList = (master.villager_enchantments || [])
        .filter(e => e && e.active !== false && typeof e.name === "string")
        .map(e => e.name.trim())
        .filter(Boolean)
        .sort((a,b)=>a.localeCompare(b));

      _addonList = Array.isArray(master.non_enchantments)
        ? master.non_enchantments.map(s => normalize(s)).filter(Boolean).sort((a,b)=>a.localeCompare(b))
        : [];

      _bestSet = renderOptimizationPanels(_villagers, _goalList, _addonList);
      renderTableAndCards(_villagers, _goalList, _addonList, _bestSet);

      const rerender = () => {
        if (!_villagers) return;
        renderTableAndCards(_villagers, _goalList, _addonList, _bestSet);
      };
      $("search").oninput = rerender;
      $("onlyGoal").onchange = rerender;
      $("onlyCost1").onchange = rerender;

    } catch (e) {
      console.error(e);
      $("status").innerHTML = `<span class="error">Error:</span> ${escapeHtml(e.message)}`;
    }
  }

  $("reloadBtn").addEventListener("click", reload);

  const vf = $("villagerFile");
  if (vf) {
    // If URL has ?file=..., select it (if it exists in the dropdown)
    const fromURL = getFileFromURL();
    if (fromURL) {
      const match = [...vf.options].find(o => o.value === fromURL);
      if (match) vf.value = fromURL;
    } else {
      // No param yet -> write current default to URL
      setFileInURL(vf.value);
    }

    // When user changes dropdown, persist in URL and reload
    vf.addEventListener("change", () => {
      setFileInURL(vf.value);
      reload();
    });
  }

  reload();

})();
</script>

</body>
</html>
